use circuits::layered_circuit::utils::get_gate_properties;
use p3_field::{ExtensionField, Field};
use poly::{Fields, MultilinearExtension, mle::MultilinearPoly, vpoly::VPoly};
use std::rc::Rc;
use sum_check::primitives::SumCheckProof;

pub struct ProveLibraInput<'a, F: Field, E: ExtensionField<F>> {
    pub claimed_sum: &'a Fields<F, E>,
    pub igz: &'a [Fields<F, E>],
    pub mul_ahg: &'a [Fields<F, E>],
    pub add_b_ahg: &'a [Fields<F, E>],
    pub add_c_ahg: &'a [Fields<F, E>],
    pub add_i: &'a [(usize, usize, usize)],
    pub mul_i: &'a [(usize, usize, usize)],
    pub w_i_plus_one_poly: &'a MultilinearPoly<F, E>,
}

pub struct EvalNewAddNMulInput<'a, F: Field, E: ExtensionField<F>> {
    pub add_i: &'a [(usize, usize, usize)],
    pub mul_i: &'a [(usize, usize, usize)],
    pub alpha_n_beta: &'a [Fields<F, E>],
    pub rb: &'a [Fields<F, E>],
    pub rc: &'a [Fields<F, E>],
    pub bc: &'a [Fields<F, E>],
    pub wb: &'a Fields<F, E>,
    pub wc: &'a Fields<F, E>,
}

pub fn generate_eq<F: Field, E: ExtensionField<F>>(points: &[Fields<F, E>]) -> Vec<Fields<F, E>> {
    let mut res = vec![Fields::Extension(E::one())];

    for point in points {
        let mut v = vec![];
        for val in &res {
            v.push(*val * (Fields::Extension(E::one()) - *point));
            v.push(*val * *point);
        }
        res = v;
    }

    res
}

pub fn igz_n_to_1_fold<F: Field, E: ExtensionField<F>>(
    challenges: &[&[Fields<F, E>]],
    alphas: &[Fields<F, E>],
) -> Vec<Fields<F, E>> {
    // get new Igz by doing a random linear combination of all igz's generated by the challenges
    challenges
        .iter()
        .enumerate()
        .map(|(index, challenge)| {
            generate_eq(challenge)
                .iter()
                .map(|val| *val * alphas[index])
                .collect::<Vec<Fields<F, E>>>()
        })
        .reduce(|acc, val| {
            acc.iter()
                .zip(val)
                .map(|(rhs, lhs)| *rhs + lhs)
                .collect::<Vec<Fields<F, E>>>()
        })
        .unwrap()
}

// Algorithm 4
pub fn initialize_phase_one<F: Field, E: ExtensionField<F>>(
    igz: &[Fields<F, E>],
    f1: &[(usize, usize, usize)],
    f3: &[Fields<F, E>],
) -> Vec<Fields<F, E>> {
    let mut res = vec![Fields::Extension(E::zero()); f3.len()];

    for (z, x, y) in f1 {
        // It is assumed the operation poly outputs 1 where there is a valid gate
        res[*x] += igz[*z] * f3[*y];
    }

    res
}

// Algorithm 5
pub fn initialize_phase_two<F: Field, E: ExtensionField<F>>(
    igz: &[Fields<F, E>],
    iux: &[Fields<F, E>],
    f1: &[(usize, usize, usize)],
) -> Vec<Fields<F, E>> {
    let mut res = vec![Fields::Extension(E::zero()); iux.len()];

    for (z, x, y) in f1 {
        // It is assumed the operation poly outputs 1 where there is a valid gate
        res[*y] += igz[*z] * iux[*x];
    }

    res
}

// Combines a vector of sumcheck proofs into one sumcheck proof
pub fn combine_sumcheck_proofs<F: Field, E: ExtensionField<F>>(
    sumcheck_proofs: Vec<SumCheckProof<F, E>>,
) -> SumCheckProof<F, E> {
    sumcheck_proofs
        .into_iter()
        .reduce(|mut acc, val| {
            acc.round_polynomials
                .extend_from_slice(&val.round_polynomials);
            acc
        })
        .unwrap()
}

pub fn prepare_phase_one_params<F: Field, E: ExtensionField<F>>(
    igz: &[Fields<F, E>],
    add_i: &[(usize, usize, usize)],
    mul_i: &[(usize, usize, usize)],
    w_i_plus_one: &[Fields<F, E>],
) -> (Vec<Fields<F, E>>, Vec<Fields<F, E>>, Vec<Fields<F, E>>) {
    let ident = vec![Fields::Extension(E::one()); w_i_plus_one.len()];

    // Build Ahg for mul, add_b and add_c
    let mul_ahg = initialize_phase_one(igz, mul_i, w_i_plus_one);

    let add_b_ahg = initialize_phase_one(igz, add_i, &ident);

    let add_c_ahg = initialize_phase_one(igz, add_i, w_i_plus_one);

    (mul_ahg, add_b_ahg, add_c_ahg)
}

// hg(x)
pub fn build_phase_one_libra_sumcheck_poly<F: Field, E: ExtensionField<F>>(
    mul_ahg: &[Fields<F, E>],
    add_b_ahg: &[Fields<F, E>],
    add_c_ahg: &[Fields<F, E>],
    w_i_plus_one_poly: &MultilinearPoly<F, E>,
) -> VPoly<F, E> {
    let n_vars = w_i_plus_one_poly.num_vars();

    VPoly::new(
        vec![
            MultilinearPoly::new_from_vec(n_vars, mul_ahg.to_vec()),
            MultilinearPoly::new_from_vec(n_vars, add_b_ahg.to_vec()),
            MultilinearPoly::new_from_vec(n_vars, add_c_ahg.to_vec()),
            w_i_plus_one_poly.clone(),
        ],
        2,
        n_vars,
        Rc::new(|data: &[Fields<F, E>]| (data[3] * (data[0] + data[1])) + data[2]),
    )
}

pub fn prepare_phase_two_params<F: Field, E: ExtensionField<F>>(
    igz: &[Fields<F, E>],
    u: &[Fields<F, E>],
    add_i: &[(usize, usize, usize)],
    mul_i: &[(usize, usize, usize)],
) -> (Vec<Fields<F, E>>, Vec<Fields<F, E>>) {
    let iux = generate_eq(u);

    // Build Af1 for mul and add
    let mul_af1 = initialize_phase_two(igz, &iux, mul_i);

    let add_af1 = initialize_phase_two(igz, &iux, add_i);

    (mul_af1, add_af1)
}

pub fn build_phase_two_libra_sumcheck_poly<F: Field, E: ExtensionField<F>>(
    mul_af1: &[Fields<F, E>],
    add_af1: &[Fields<F, E>],
    wb: &Fields<F, E>,
    w_i_plus_one_poly: &MultilinearPoly<F, E>,
) -> VPoly<F, E> {
    let n_vars = w_i_plus_one_poly.num_vars();

    VPoly::new(
        vec![
            MultilinearPoly::new_from_vec(n_vars, mul_af1.to_vec()),
            MultilinearPoly::new_from_vec(n_vars, add_af1.to_vec()),
            MultilinearPoly::new_from_vec(n_vars, vec![*wb; w_i_plus_one_poly.evaluations.len()]),
            w_i_plus_one_poly.clone(),
        ],
        2,
        n_vars,
        Rc::new(|data: &[Fields<F, E>]| {
            (data[0] * data[2] * data[3]) + (data[1] * (data[2] + data[3]))
        }),
    )
}

pub struct SparsePoly<F: Field, E: ExtensionField<F>> {
    // contains a vec of tuple of index and evaluation
    pub n_vars: usize,
    pub evals: Vec<(usize, Fields<F, E>)>,
}

impl<F: Field, E: ExtensionField<F>> SparsePoly<F, E> {
    pub fn new(n_vars: usize, evals: Vec<(usize, Fields<F, E>)>) -> Self {
        Self { n_vars, evals }
    }

    pub fn evaluate(&self, points: &[Fields<F, E>]) -> Fields<F, E> {
        let basis = generate_eq(points);

        self.evals
            .iter()
            .fold(Fields::Extension(E::zero()), |mut acc, (index, val)| {
                acc += basis[*index] * *val;
                acc
            })
    }
}

pub fn to_sparse_poly<F: Field, E: ExtensionField<F>>(
    gates: &[(usize, usize, usize)],
    layer_index: usize,
    n_vars: usize,
) -> SparsePoly<F, E> {
    // convert gate tuple to index and value pairs
    let valid_gate_index_and_value = gates
        .iter()
        .map(|(a, b, c)| {
            (
                get_gate_properties(*a, *b, *c, layer_index),
                Fields::from_u32(1),
            )
        })
        .collect::<Vec<(usize, Fields<F, E>)>>();
    SparsePoly::new(n_vars, valid_gate_index_and_value)
}

pub fn eval_layer_mle_given_wb_n_wc<F: Field, E: ExtensionField<F>>(
    add_i: &[(usize, usize, usize)],
    mul_i: &[(usize, usize, usize)],
    challenges: &[Fields<F, E>],
    wb: &Fields<F, E>,
    wc: &Fields<F, E>,
    layer_index: usize,
    n_vars: usize,
) -> Fields<F, E> {
    let addi_poly = to_sparse_poly(add_i, layer_index, n_vars);
    let muli_poly = to_sparse_poly(mul_i, layer_index, n_vars);

    (addi_poly.evaluate(challenges) * (*wb + *wc)) + (muli_poly.evaluate(challenges) * (*wb * *wc))
}

pub fn eval_new_addi_n_muli_at_rb_bc_n_rc_bc<F: Field, E: ExtensionField<F>>(
    input: EvalNewAddNMulInput<'_, F, E>,
    layer_index: usize,
    n_vars: usize,
) -> Fields<F, E> {
    let addi_poly = to_sparse_poly(input.add_i, layer_index, n_vars);
    let muli_poly = to_sparse_poly(input.mul_i, layer_index, n_vars);

    let rb_bc = [input.rb, input.bc].concat();

    let rc_bc = [input.rc, input.bc].concat();

    let addi_rb_b_c = addi_poly.evaluate(&rb_bc);
    let addi_rc_b_c = addi_poly.evaluate(&rc_bc);
    let muli_rb_b_c = muli_poly.evaluate(&rb_bc);
    let muli_rc_b_c = muli_poly.evaluate(&rc_bc);

    let new_addi = (input.alpha_n_beta[0] * addi_rb_b_c) + (input.alpha_n_beta[1] * addi_rc_b_c);
    let new_muli = (input.alpha_n_beta[0] * muli_rb_b_c) + (input.alpha_n_beta[1] * muli_rc_b_c);

    (new_addi * (*input.wb + *input.wc)) + (new_muli * (*input.wb * *input.wc))
}

#[cfg(test)]
mod tests {
    use p3_field::{AbstractExtensionField, AbstractField, extension::BinomialExtensionField};
    use p3_mersenne_31::Mersenne31;
    use poly::Fields;

    use crate::utils::{generate_eq, initialize_phase_one, initialize_phase_two};

    type F = Mersenne31;
    type E = BinomialExtensionField<F, 3>;

    #[test]
    fn test_precompute() {
        let challenges = Fields::<F, E>::from_u32_vec(vec![1, 3, 5]);

        let precomputed = generate_eq(&challenges);

        let expected = [
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(8),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(10),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(12),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(15),
            )),
        ];

        assert_eq!(precomputed, expected);
    }

    #[test]
    fn test_build_ahg() {
        //
        //       12      30      56      90
        //       *       *       *       *
        //     /   \   /   \   /   \   /   \
        //     3   4   5   6   7   8   9   10
        //

        // values (3,5) were used to generate the Igz table
        // (1-a)(1-b) = (1-3)(1-5) = 8
        // (1-a)b = (1-3) 5 = -10
        // a(1-b) = 3 (1-5) = -12
        // ab = 3*5 = 15

        let igz = [
            Fields::<F, E>::from_u32(8),
            -Fields::from_u32(10),
            -Fields::from_u32(12),
            Fields::from_u32(15),
        ];

        // f(out, left, right) in the sparse form
        let f1 = vec![(0, 0, 1), (1, 2, 3), (2, 4, 5), (3, 6, 7)];

        let f3 = vec![
            Fields::from_u32(3),
            Fields::from_u32(4),
            Fields::from_u32(5),
            Fields::from_u32(6),
            Fields::from_u32(7),
            Fields::from_u32(8),
            Fields::from_u32(9),
            Fields::from_u32(10),
        ];

        let ahg = initialize_phase_one(&igz, &f1, &f3);

        let expected = [
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(32),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(0),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(60),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(0),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(96),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(0),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(150),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_u32(0),
            )),
        ];

        assert_eq!(ahg, expected);
    }

    #[test]
    fn test_build_af1() {
        //
        //       12      30      56      90
        //       *       *       *       *
        //     /   \   /   \   /   \   /   \
        //     3   4   5   6   7   8   9   10
        //

        // values (3,5) were used to generate the Igz table
        // (1-a)(1-b) = (1-3)(1-5) = 8
        // (1-a)b = (1-3) 5 = -10
        // a(1-b) = 3 (1-5) = -12
        // ab = 3*5 = 15

        let igz = [
            Fields::<F, E>::from_u32(8),
            -Fields::from_u32(10),
            -Fields::from_u32(12),
            Fields::from_u32(15),
        ];

        // values (4,7,3) were used to generate the Iux table
        // (1-a)(1-b)(1-c) = (1-4)(1-7)(1-3) = -36
        // (1-a)(1-b)c = (1-4)(1-7)3 = 54
        // (1-a)b(1-c) = (1-4)7(1-3) = 42
        // (1-a)b*c = (1-4)*7*3 = -63
        // a(1-b)(1-c) = 4*(1-7)*(1-3) = 48
        // a(1-b)c = 4*(1-7)*3 = -72
        // a*b(1-c) = 4*7*(1-3) = -56
        // a*b*c = 4*7*3 = 84

        let iux = [
            -Fields::from_u32(36),
            Fields::from_u32(54),
            Fields::from_u32(42),
            -Fields::from_u32(63),
            Fields::from_u32(48),
            -Fields::from_u32(72),
            -Fields::from_u32(56),
            Fields::from_u32(84),
        ];

        // f(out, left, right) in the sparse form
        let f1 = vec![(0, 0, 1), (1, 2, 3), (2, 4, 5), (3, 6, 7)];

        let af1 = initialize_phase_two(&igz, &iux, &f1);

        let expected = [
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(288),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(420),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(576),
            )),
            Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(0),
            )),
            -Fields::Extension(BinomialExtensionField::from_base(
                Mersenne31::from_canonical_usize(840),
            )),
        ];

        assert_eq!(af1, expected);
    }
}
